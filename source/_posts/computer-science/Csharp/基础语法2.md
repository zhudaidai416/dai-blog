---
title: 基础语法2
date: 2024-10-11 08:59:25
category:
  - [计算机与科学, C#]
tags: C#
cover: https://daiblog.oss-cn-chengdu.aliyuncs.com/cover/2-2.jpg
---

# 操作符（运算符）

- 操作符（Operator）也译为“运算符”
- 操作符是用来操作数据的，被操作符操作的数据称为操作数（Operand）

## 本质

- 操作符的本质是函数（即算法）的“简记法”

- 操作符不能脱离与它关联的数据类型

  - 可以说操作符就是与固定数据类型相关联的一套基本算法的简记法

  - 为自定义数据类型创建操作符

  - +++success 示例：不能脱离与它关联的数据类型
  
    ```csharp
    int x = 5;
    int y = 4;
    int z = x / y;
    Console.WriteLine(z); // 1
    
    double a = 5.0;
    double b = 4.0;
    double c = a / b;
    Console.WriteLine(c); // 1.25
    ```
  
    +++

## 优先级

![img](https://daiblog.oss-cn-chengdu.aliyuncs.com/csharp/1542070693640-b030aa8e-ca29-4f0a-9239-6b5db32c99b6.png)

- 操作符的优先级
  - 可以使用圆括号提高被括起来表达式的优先级
  - 圆括号可以嵌套
  - 不像数学里有方括号与花括号，在 C# 语言里面“[]”与“{}”有专门的用途
- 同优先级操作符的运算顺序
  - 除了带有赋值功能的操作符，同优先级操作符都由左向右进行运算
  - 带有赋值功能的操作符的运算顺序是由右向左
  - 与数学运算不同，计算机语言的同优先级运算没有“结合率”

## 基本操作符

### `.` 成员访问

```csharp
System.IO.File.Create("D:\\HelloWorld.txt");
      1  2    3
var myForm = new Form();
myForm.Text = "Hello, World";
myForm.ShowDialog();
      4
➡ 1、访问外层名称空间中的子名称空间
➡ 2、访问名称空间中的类型
➡ 3、访问类型的静态成员
➡ 4、访问对象中的实例成员
```

### `f(x)` 方法调用

```cs
namespace OperatorsExample
{
  class Program
  {
    static void Main(string[] args)
    {
      var c = new Calculator();
      double x = c.Add(3.0, 4.6);
      Console.WriteLine(x);

      Action myAction = new Action(c.PrintHello); // 委托：只需要知道方法的名称，不调用方法
      myAction();
    }
  }

  class Calculator
  {
    public double Add(double a,double b)
    {
      return a + b;
    }

    public void PrintHello()
    {
      Console.WriteLine("Hello");
    }
  }
}
```

### `a[x]` 元素访问

```csharp
// 访问数组元素
int[] myIntArray = new int[] { 1, 2, 3, 4, 5 }; // {}初始化器
Console.WriteLine(myIntArray[0]);
Console.WriteLine(myIntArray[myIntArray.Length - 1]);

// 访问字典中的元素
class Program
{
  static void Main(string[] args)
  {
    Dictionary<string, Student> stuDic = new Dictionary<string, Student>(); // 泛型
    for (int i = 0; i < 100; i++)
    {
      var stu = new Student()
      {
        Name = "s_" + i.ToString(),
        Score = 100 - i
      };
      stuDic.Add(stu.Name, stu); // stu.Name 当作索引，stu 对象当作值
    }
    Console.WriteLine(stuDic["s_6"].Score); // 索引不一样是整数
  }
}

class Student
{
  public string Name;
  public int Score;
}
```

### `x++ x--` 后置自增、自减

```csharp
int x = 100;
int y = x++;
Console.WriteLine(x); // 101
Console.WriteLine(y); // 100
```

### `typeof` 检测类型

```csharp
// Metadata：检测类型元数据
Type t = typeof(int);
Console.WriteLine(t.Namespace); // System
Console.WriteLine(t.FullName); // System.Int32
Console.WriteLine(t.Name); // Int32

int c = t.GetMethods().Length;
Console.WriteLine(c);
foreach (var m in t.GetMethods())
{
  Console.WriteLine(m.Name);
}
```

![img](https://daiblog.oss-cn-chengdu.aliyuncs.com/csharp/1542071068098-859ffb89-89cc-4ee4-ba4e-f2e8f8d3ba9b.png)

`default`

```csharp
namespace OperatorsExample
{
  class Program
  {
    static void Main(string[] args)
    {
      // 1、结构体类型 - 值类型内存块都刷成0，值是0
      int x = default(int);
      Console.WriteLine(x); // 0

      // 2、引用类型 - 内存块刷成0没有引用，值是null
      Form myForm = default(Form);
      Console.WriteLine(myForm == null); // True

      // 3、枚举类型 - 映射到整型上，默认枚举值是对应值为0的那个
      // 要注意枚举中是否有对应0的；创建枚举类型时，最好有一个对应0的，以免他人查找我们枚举的default值时报错
      Level level = default(Level);
      Console.WriteLine(level); // High
    }
  }

  enum Level
  {
    // 不给定值，系统默认赋值，依次从0开始
    // 手动指定的
    Low = 1,
    Mid = 2,
    High = 0
  }
}
```

### `new`

```csharp
// 1、在内存中创建类型实例，并调用实例构造器，把实例地址通过赋值操作符交给访问它的变量
var myForm = new Form(); // var：隐式类型变量

// 2、可以调用实例的初始化器
var myForm2 = new Form()
{
  Text = "Hello",
  FormBorderStyle = FormBorderStyle.SizableToolWindow
};

// 一次性变量：利用实例的初始化器直接new对象后，马上执行方法，因为没有引用，垃圾收集器会回收
new Form() { Text = "Hello" }.ShowDialog();

// 3、为匿名类型创建对象，用隐式类型变量（var）来引用这个实例
var person = new { Name = "Mr.Okay", Age = 34};
Console.WriteLine(person.Name);
Console.WriteLine(person.Age);
Console.WriteLine(person.GetType().Name);
```

![img](https://daiblog.oss-cn-chengdu.aliyuncs.com/csharp/1542071192665-d0866d99-bcdf-48a2-9603-fe295a60392b.png)

通过 C# 的语法糖，我们在声明常用类型的变量时不需要 new 操作符

```csharp
string name = "Tim";
string name2 = new string(new char[]{ 'T', 'i', 'm' });

int[] myArray1 = { 1, 2, 3, 4 };
int[] myArray2 = new int[4];
```

new 操作符会导致依赖紧耦合，可以通过依赖注入模式来将紧耦合变成相对松的耦合

```csharp
// new 操作符功能强大，但会造成依赖。new 出 myForm 后，Program class 就依赖到 myForm 上了，
// 一旦 myForm 运行出错，Program 类也会出问题
// 通过设计模式中的依赖注入模式来将紧耦合变成相对松的耦合
var myForm = new Form() { Text = "Hello" };
```

new 作为关键字

```csharp
class Program
{
  static void Main(string[] args)
  {
    var stu = new Student(); // 此处new是操作符
    stu.Report(); // I'm a student.
    var csStu = new CsStudent();
    csStu.Report();
  }
}

class Student
{
  public void Report()
  {
    Console.WriteLine("I'm a student.");
  }
}

class CsStudent:Student // 继承/派生
{
  new public void Report() // 此处new是修饰符，子类把父类的方法隐藏掉
  {
    Console.WriteLine("I'm CS student.");
  }
}
```

### `checked` & `unchecked`

检查一个值在内存中是否有溢出

```csharp
uint x = uint.MaxValue;
Console.WriteLine(x); // 4294967295
var binStr = Convert.ToString(x, 2);
Console.WriteLine(binStr); // 1111 1111 1111 1111 1111 1111 1111 1111

uint y = x + 1;
Console.WriteLine(y); // 0，值溢出

// checked
try
{
  uint y = checked(x + 1);
  Console.WriteLine(y); // 此处程序抛出异常
}
catch (OverflowException ex)
{
  Console.WriteLine("There's overflow!");
}

// unchecked：不检验溢出
try
{
  // C# 默认采用的就是 unchecked 模式
  uint y = unchecked(x + 1);
  Console.WriteLine(y);
}
catch (OverflowException ex)
{
  Console.WriteLine("There's overflow!");
}
```

checked 与 unchecked 的另一种用法：上下文用法

```csharp
uint x = uint.MaxValue;
Console.WriteLine(x);
var binStr = Convert.ToString(x, 2);
Console.WriteLine(binStr);

// unchecked
checked
{
  try
  {
    uint y = x + 1;
    Console.WriteLine(y);
  }
  catch (OverflowException ex)
  {
    Console.WriteLine("There's overflow!");
  }
}
```

### `delegate`

常见的是把 delegate 当做委托关键字使用

delegate 也可以作为操作符使用，但由于 Lambda 表达式的流行，delegate 作为操作符的场景愈发少见（被 Lambda 替代，已经过时）

```csharp
public partial class MainWindow : Window
{
  public MainWindow()
  {
    InitializeComponent();

    // 方法封装提高了复用性，但如果我这个方法在别的地方不太可能用到，我就可以使用匿名方法
    // 使用 delegate 来声明匿名方法
    this.myButton.Click += delegate (object sender, RoutedEventArgs e)
    {
      this.myTextBox.Text = "Hello, World!";
    }; 

    // 现在推荐使用的是 Lambda 表达式
    this.myButton.Click += (sender, e) =>
    {
      this.myTextBox.Text = "Hello, World!";
    };
  }

  // 非匿名方法
  private void MyButton_Click(object sender, RoutedEventArgs e)
  {
    this.myTextBox.Text = "Hello, World!";
  }
}
```

### `sizeof`

用于获取对象在内存中所占字节数默认情况下

> :warning: 注：
>
> - sizeof 只能获取结构体类型的实例在内存中的字节数
>   - int、uint、double 可以
>   - string、object 不行
> - 非默认情况下，可以使用 sizeof 获取自定义结构体类型的大小，但需要把它放在不安全的上下文中

需要在“项目属性”里面开启“允许不安全代码”

![img](https://daiblog.oss-cn-chengdu.aliyuncs.com/csharp/1542071413076-c6f4f278-afd4-4794-a569-8466f63ed907.png)

```csharp
class Program
{
  static void Main(string[] args)
  {
    var x = sizeof(int);
    Console.WriteLine(x); // 4

    unsafe
    {
      int y = sizeof(Student);
      Console.WriteLine(y); // 16
    }
  }
}
struct Student
{
  int ID;
  long Score;
}
```

> :warning: 注：int 字节数为 4，long 字节数为 8。但 sizeof(Student) 结果是 16。这涉及到了 .NET 对内存的管理，超出了现在所学内容

# 表达式



# 语句

# 字段

# 属性

# 索引器

# 常量

# 参数

# 委托

# 数据类型

- 值类型：简单类型（如 int、float、bool 和 char）、枚举类型、结构类型、Nullable 值类型
- 引用类型：类类型、接口类型、数组类型、委托类型

![数据类型](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fefbc908dfcb4436bcda4911220528f4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

| 描述                  | 类型                                                         |
| --------------------- | ------------------------------------------------------------ |
| Unicode 字符（16 位） | char                                                         |
| 布尔值                | bool                                                         |
| 有符号整数            | sbyte（8 位）< short（16 位）< int（32 位）< long（64 位）   |
| 正整数                | byte（8 位）< ushort（16 位）< uint（32 位）< ulong（64 位） |
| 浮点数                | float（32 位）< double（64 位）                              |
| 时间                  | DateTime                                                     |

可空类型：声明时加个 `?`，才可赋值为 null

## 值类型

| 类型    | 描述                                        | 范围                                                    | 默认值 |
| ------- | ------------------------------------------- | ------------------------------------------------------- | ------ |
| bool    | 布尔值                                      | True 或 False                                           | False  |
| byte    | 8 位无符号整数                              | 0 到 255                                                | 0      |
| char    | 16 位 Unicode 字符                          | U +0000 到 U +ffff                                      | '\0'   |
| decimal | 128 位精确的十进制值，具有 28~29 个有效位数 | (-7.9 x 1028 到 7.9 x 1028) / 100 到 28                 | 0.0M   |
| double  | 64 位双精度浮点型                           | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D   |
| float   | 32 位单精度浮点型                           | -3.4 x 1038 到 + 3.4 x 1038                             | 0.0F   |
| int     | 32 位有符号整数类型                         | -2,147,483,648 到 2,147,483,647                         | 0      |
| long    | 64 位有符号整数类型                         | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |
| sbyte   | 8 位有符号整数类型                          | -128 到 127                                             | 0      |
| short   | 16 位有符号整数类型                         | -32,768 到 32,767                                       | 0      |
| uint    | 32 位无符号整数类型                         | 0 到 4,294,967,295                                      | 0      |
| ulong   | 64 位无符号整数类型                         | 0 到 18,446,744,073,709,551,615                         | 0      |
| ushort  | 16 位无符号整数类型                         | 0 到 65,535                                             | 0      |

使用 `sizeof()` 获取类型或变量的大小

## 引用类型

### 对象类型 Object

```csharp
Object obj;
obj = 100; // 装箱
```

### 动态类型 Dynamic

可以存储任何类型的值在动态数据类型变量中

```csharp
dynamic d = 20;
```

### 字符串类型 String

字符串（String）类型是 System.String 类的别名

通过两种形式进行分配：`引号 和 @引号`

```csharp
String str = "zhudaidai";

// @（称作"逐字字符串"）将转义字符（\）当作普通字符对待，若要显示"，则要打多个"
string str = @"C:\Windows"""; // 输出 C:\Windows"
等同于
string str = "C:\\Windows"; // 输出 C:\Windows

// @内可以任意换行：换行符及缩进空格都计算在字符串长度之内
string str = @"<script type=""text/javascript"">
  <!--
  -->
</script>";
```

## 指针类型

# 运算符

## 算术运算符

假设 `A=10 B=20`

| 运算符 | 描述                             | 实例              |
| :----- | :------------------------------- | :---------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30   |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10  |
| \*     | 把两个操作数相乘                 | A \* B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2    |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0    |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11     |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9      |

## 关系运算符

假设 `A=10 B=20`

| 运算符 | 描述                                                         | 实例            |
| :----- | :----------------------------------------------------------- | :-------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真               | (A == B) 不为真 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真             | (A != B) 为真   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真       | (A > B) 不为真  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真       | (A < B) 为真    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真 | (A >= B) 不为真 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真 | (A <= B) 为真   |

## 逻辑运算符

假设 `A=true B=false`

| 运算符 | 描述                                                                         | 实例            |
| :----- | :--------------------------------------------------------------------------- | :-------------- |
| &&     | 逻辑与运算符。如果两个操作数都非零，则条件为真                               | (A && B) 为假   |
| \|\|   | 逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真                     | (A \|\| B) 为真 |
| !      | 逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假 |                 |

## 合并运算符

合并运算符 `??`：如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值

```csharp
int? num1 = null;
int num2 = num1 ?? 123;

// 可以理解为三元运算符的简化形式
int num2 = (num1 == null) ? 123 : num1;
```

## 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p & q | p \| q | p ^ q |
| :-- | :-- | :---- | :----- | :---- |
| 0   | 0   | 0     | 0      | 0     |
| 0   | 1   | 0     | 1      | 1     |
| 1   | 1   | 1     | 1      | 0     |
| 1   | 0   | 0     | 1      | 1     |

假设 `A=60 B=13`

| 运算符 | 描述                                                                                   | 实例                                                           |
| :----- | :------------------------------------------------------------------------------------- | :------------------------------------------------------------- |
| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中                          | (A & B) 将得到 12，即为 0000 1100                              |
| \|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中                               | (A \| B) 将得到 61，即为 0011 1101                             |
| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中 | (A ^ B) 将得到 49，即为 0011 0001                              |
| ~      | 按位取反运算符是一元运算符，具有"翻转"位效果，即 0 变成 1，1 变成 0，包括符号位        | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式 |
| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数                               | A << 2 将得到 240，即为 1111 0000                              |
| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数                               | A >> 2 将得到 15，即为 0000 1111                               |

+++success 案例

```csharp
int a = 60; // 60 = 0011 1100
int b = 13; // 13 = 0000 1101
int c = 0;

c = a & b; // 12 = 0000 1100
Console.WriteLine("Line 1 - c 的值是 {0}", c);

c = a | b; // 61 = 0011 1101
Console.WriteLine("Line 2 - c 的值是 {0}", c);

c = a ^ b; // 49 = 0011 0001
Console.WriteLine("Line 3 - c 的值是 {0}", c);

c = ~a; // -61 = 1100 0011
Console.WriteLine("Line 4 - c 的值是 {0}", c);

c = a << 2; // 240 = 1111 0000
Console.WriteLine("Line 5 - c 的值是 {0}", c);

c = a >> 2; // 15 = 0000 1111
Console.WriteLine("Line 6 - c 的值是 {0}", c);
Console.ReadLine();
```

+++

## 赋值运算符

| 运算符 | 描述                                                             | 实例                            |
| :----- | :--------------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数                 | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| \*=    | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C _= A 相当于 C = C_ A          |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数               | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                                 | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                                 | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                               | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                             | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                               | C \|= 2 等同于 C = C \| 2       |

## 其他运算符

| 运算符   | 描述                                 | 实例                                                                              |
| :------- | :----------------------------------- | :-------------------------------------------------------------------------------- |
| sizeof() | 返回数据类型的大小                   | sizeof(int)，将返回 4                                                             |
| typeof() | 返回 class 的类型                    | typeof(StreamReader);                                                             |
| &        | 返回变量的地址                       | &a; 将得到变量的实际地址。                                                        |
| \*       | 变量的指针                           | \*a; 将指向一个变量。                                                             |
| ? :      | 条件表达式                           | 如果条件为真 ? 则为 X : 否则为 Y                                                  |
| is       | 判断对象是否为某一类型               | If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。                           |
| as       | 强制转换，即使转换失败也不会抛出异常 | Object obj = new StringReader("Hello"); <br>StringReader r = obj as StringReader; |

+++success 案例

```csharp
Console.WriteLine("int 的大小是 {0}", sizeof(int)); // int的大小是4
Console.WriteLine("short 的大小是 {0}", sizeof(short)); // short的大小是2

Type type = typeof(string);
Console.WriteLine(type.FullName); // System.String
Console.ReadKey();
```

+++

## 运算符优先级

| 类别       | 运算符                              | 结合性   |
| :--------- | :---------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                   | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)\* & sizeof    | 从右到左 |
| 乘除       | \* / %                              | 从左到右 |
| 加减       | + -                                 | 从左到右 |
| 移位       | << >>                               | 从左到右 |
| 关系       | < <= > >=                           | 从左到右 |
| 相等       | == !=                               | 从左到右 |
| 位与 AND   | &                                   | 从左到右 |
| 位异或 XOR | ^                                   | 从左到右 |
| 位或 OR    | \|                                  | 从左到右 |
| 逻辑与 AND | &&                                  | 从左到右 |
| 逻辑或 OR  | \|\|                                | 从左到右 |
| 条件       | ?:                                  | 从右到左 |
| 赋值       | = += -= \*= /= %= >>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                   | 从左到右 |

# 条件/分支

## if

```csharp
if (条件)
{
  ...
}
else if ()
{
  ...
}
else
{
  ...
}
```

## switch

```csharp
switch (变量)
{
  case 条件1:
    ...
    break;
  case 条件2:
    ...
    break;
  default:
    ...
    break;
}
```

## 三元运算符

```csharp
Exp1 ? Exp2 : Exp3;
```

# 循环

| 循环类型         | 描述                                                               | 使用场景       |
| :--------------- | ------------------------------------------------------------------ | :------------- |
| while 循环       | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 | 确定循环条件   |
| for/foreach 循环 | 多次执行一个语句序列，简化管理循环变量的代码                       | 确定次数       |
| do...while 循环  | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似            | 至少被执行一次 |
| 嵌套循环         | 可以在 while、for 或 do..while 循环内使用一个或多个循环            |                |

```csharp
int i = 0;
while(i < 10)
{
  Console.WriteLine(i);
  i++;
}


int i = 0;
do
{
  Console.WriteLine(i);
  i++;
} while (i < 10);


for (int i = 0; i < 10; i++)
{
  Console.WriteLine(i);
}

int i = 0;
for ( ; i < 10; )
{
  Console.WriteLine(i);
  i++;
}
for( ; ; ) // 死循环
```

## 循环控制语句

| 控制语句      | 描述                       |
| ------------- | -------------------------- |
| break 语句    | 结束整个循环               |
| continue 语句 | 中止当前循环，继续下次循环 |

# 方法（函数）

```csharp
<Access Specifier> <Return Type> <Method Name>(Parameter List)
{
  Method Body
}

➡ Access Specifier：访问修饰符
➡ Return type：返回类型，一个方法可以返回一个值
➡ Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。
➡ Parameter list：参数列表
➡ Method body：方法主体
```

+++success 举例

```csharp
// 普通方法
public void sayHi() {
  Console.WriteLine("hi");
}

// 带参数的方法
public void sayHi(string name) {
  Console.WriteLine("hi,{0}", name);
}

// 带参数的返回值的方法
public int add(int a, int b) {
  int sum = a + b;
  return sum;
}
```

+++

# Hashtable 哈希表

用于处理和表现类似 `key value` 的键值对

- key：通常可用来快速查找，区分大小写
- value：用于存储对应于 key 的值

Hashtable 中 keyvalue 键值对均为 object 类型，所以 Hashtable 可以支持任何类型的 keyvalue 键值对

## 使用场景

- 某些数据会被高频率查询
- 数据量大
- 查询字段包含字符串类型
- 数据类型不唯一

## 引入 namespace

```csharp
using System.Collections;
using System.Collections.Generic;
```

## 属性

|    属性     |                    描述                     |
| :---------: | :-----------------------------------------: |
|    Count    |      获取 Hashtable 中包含的键值对个数      |
| IsFixedSize | 获取一个值，表示 Hashtable 是否具有固定大小 |
| IsReadOnly  |     获取一个值，表示 Hashtable 是否只读     |
|    Item     |        获取或设置与指定的键相关的值         |
|    Keys     | 获取一个 ICollection，包含 Hashtable 中的键 |
|   Values    | 获取一个 ICollection，包含 Hashtable 中的值 |

## 方法

|                        方法                        |                   描述                    |
| :------------------------------------------------: | :---------------------------------------: |
| public virtual void Add(object key, object value); |                添加键值对                 |
|      public virtual void Remove(object key);       |             移除指定的键值对              |
|            public virtual void Clear();            |               移除所有元素                |
|    public virtual bool ContainsKey(object key);    | 判断是否包含指定的键 key，返回 true/false |
|  public virtual bool ContainsValue(object value);  | 判断是否包含指定键的 key，返回 true/false |

+++success 示例

```csharp
...
using System.Collections; // 必须引入命名空间
using System.Collections.Generic;

namespace HashTable
{
  class Program
  {
    static void Main(string[] args)
    {
      Hashtable ht = new Hashtable();
      ht.Add("北京", "帝都"); // 添加keyvalue键值对
      ht.Add("上海", "魔都");
      ht.Add("广州", "省会");
      ht.Add("深圳", "特区");
      Console.WriteLine(ht.Count); // 4，输出键值对个数

      ht.Remove("深圳"); // 移除键值对
      Console.WriteLine(ht.Count); // 3

      Console.WriteLine(ht.Contains("北京")); // True
      Console.WriteLine(ht.ContainsValue("省会")); // True
      Console.WriteLine(ht["上海"]); // 魔都
        
      ht.Clear(); // 移除所有
    }
  }
}
```

+++

## 遍历

```csharp
// 遍历键对
foreach (DictionaryEntry item in ht) {
  Console.WriteLine(item.Key);
  Console.WriteLine(item.Value);
}

// 遍历键
foreach (string key in ht.Keys) {
Console.WriteLine(key);
}

// 遍历值
foreach (string value in ht.Values) {
  Console.WriteLine(value);
}
```

## 排序

```csharp
ArrayList akeys = new ArrayList(ht.Keys);
akeys.Sort(); // 按字母顺序进行排序
foreach (string key in akeys) {
  Console.WriteLine(key + ": " + ht[key]);  // 排序后输出
}

// 输出：
北京: 帝都
广州: 省会
上海: 魔都
```

# DataTable

DataTable 是一个临时保存数据的网格虚拟表,表示内存中数据的一个表，是一个二维表，也是一个后台数据源和前台显示之间的适配器

## 引入 namespace

```csharp
using System.Data;
```

## 属性

|      属性       |                             描述                             |
| :-------------: | :----------------------------------------------------------: |
|    TableName    |                 获取或设置 DataTable 的名称                  |
|     Columns     |                    获取属于该表的列的集合                    |
|      Rows       |                    获取属于该表的行的集合                    |
|     DataSet     |                    获取此表所属的 DataSet                    |
| ChildRelations  |               获取此 DataTable 的子关系的集合                |
|   Constraints   |                  获取由该表维护的约束的集合                  |
|   DefaultView   |        获取可能包括筛选视图或游标位置的表的自定义视图        |
|  CaseSensitive  |              指示表中的字符串比较是否区分大小写              |
|    HasErrors    | 获取一个值，该值指示该表所属的 DataSet 的任何表的任何行中是否有错误 |
| MinimumCapacity | 获取或设置该表最初的起始大小。该表中行的最初起始大小，默认值为 50 |

## 方法

|          属性          |                             描述                             |
| :--------------------: | :----------------------------------------------------------: |
|      BeginInit()       |          开始初始化在窗体上使用或由另一个组件使用的          |
|       DataTable        |                      初始化发生在运行时                      |
|        Clear()         |                   清除所有数据的DataTable                    |
|        Clone()         |     克隆 DataTable 的结构，包括所有 DataTable 架构和约束     |
|       EndInit()        | 结束在窗体上使用或由另一个组件使用的 DataTable 的初 始化。初始化发生在运行时 |
| ImportRow(DataRow row) | 将 DataRow 复制到 DataTable 中，保留任何属性设置以及初始值和当前值 |
| Merge(DataTable table) |          将指定的 DataTable 与当前的 DataTable 合并          |
|        NewRow()        |              创建与该表具有相同架构的新DataRow               |

## 常用使用方法

| 字段名 | column0 | column1               |
| ------ | ------- | --------------------- |
|        | 张三    | DateTime.Now 当前时间 |
|        | 李四    | DateTime.Now 当前时间 |

### 创建

```csharp
// 1、创建一个空表
DataTable dt = new DataTable();

// 2、创建一个名为"Table_New"的空表
DataTable dt = new DataTable("Table_New");

// 3、指定的表名和命名空间初始化 DataTable 类的新实例
// DataTable(string tableName, string tableNamespace) 
DataTable dt = new DataTable("Table_New","Test");
```

### 添加列

```csharp
// 1、创建空列
DataColumn dc = new DataColumn();
dt.Columns.Add(dc);

// 2、创建带列名和类型名的列(两种方式任选其一)
dt.Columns.Add("column0", System.Type.GetType("System.String"));
dt.Columns.Add("column0", typeof(String));

// 3、通过列架构添加列
DataColumn dc = new DataColumn("column1",System.Type.GetType("System.DateTime"));
DataColumn dc = new DataColumn("column1", typeof(DateTime));
dt.Columns.Add(dc);
```

### 添加行

```csharp
// 1、创建空行
DataRow dr = dt.NewRow();
dt.Rows.Add(dr);

// 2、创建空行
dt.Rows.Add();

// 3、通过行框架创建并赋值
dt.Rows.Add("张三", DateTime.Now);// Add里面参数的数据顺序要和dt中的列的顺序对应

// 4、通过复制dt2表的某一行来创建
dt.Rows.Add(dt2.Rows[i].ItemArray);
```

### 赋值取值

赋值

```csharp
// 1、新建行的赋值
DataRow dr = dt.NewRow();
dr[0] = "张三";// 通过索引赋值
dr["column1"] = DateTime.Now; // 通过名称赋值


// 2、对表已有行进行赋值
dt.Rows[0][0] = "张三"; // 通过索引赋值
dt.Rows[0]["column1"] = DateTime.Now;// 通过名称赋值
```

取值

```csharp
string name = dt.Rows[0][0].ToString();
string time = dt.Rows[0]["column1"].ToString();

// 遍历
for (int i = 0; i < dt.Rows.Count; i++) {
  // string strName = dt.Rows[i]["字段名"].ToString();   
  Console.WriteLine(dt.Rows[i]["column0"].ToString());
  Console.WriteLine(dt.Rows[i]["column1"].ToString());
}

foreach (DataRow dr in dt.Rows) {
  // object value = dr["字段名"];
  Console.WriteLine(dr["column0"]);
  Console.WriteLine(dr["column1"]);
}
```

### 筛选行

```csharp
// 选择column1列值为空的行的集合
DataRow[] drs = dt.Select("column1 is null");

// 选择column0列值为"李四"的行的集合
DataRow[] drs = dt.Select("column0 = '李四'");

// 筛选column0列值中有"张"的行的集合(模糊查询)
DataRow[] drs = dt.Select("column0 like '张%'"); // 如果的多条件筛选，可以加 and 或 or

// 筛选column0列值中有"张"的行的集合并按column1降序排序
DataRow[] drs = dt.Select("column0 like '张%'", "column1 DESC");

// DataTable.Select()方法里面支持简单的过滤和排序，不支持复杂的条件过滤和排序。里面的字符串必须是列名和数据，以及>,<,=,<>等关系运算符 
DataRow[] drs = dt.Select("column0 = '李四' and column0 = '1'");
```

### 删除行

```csharp
// 1、DataTable.Rows.Remove(DataRow)方法
dt.Rows.Remove(dt.Rows[0]);

// 2、DataTable.Rows.RemoveAt(index)方法
dt.Rows.RemoveAt(0);

// 3、DataRow.Delete()方法
dt.Rows[0].Delete();
dt.AcceptChanges();
 
// ----- ❗ 区别和注意点 -----
// Remove()和RemoveAt()方法是直接删除
// Delete()方法只是将该行标记为deleted，但是还存在，还可DataTable.RejectChanges()回滚，使该行取消删除
// 用Rows.Count来获取行数时，还是删除之前的行数，需要使用DataTable.AcceptChanges()方法来提交修改
// 如果要删除DataTable中的多行，应该采用倒序循环DataTable.Rows，而且不能用foreach进行循环删除，因为正序删除时索引会发生变化，程式发生异常，很难预料后果
for (int i = dt.Rows.Count - 1; i >= 0; i--)
{
  dt.Rows.RemoveAt(i);
}
```

### 复制表

复制表 - 同时复制了表结构和数据

```csharp
// 方法一
DataTable dtNew = new DataTable();
dtNew = dt.Copy();

// 方法二
DataTable dtNew = dt.Copy();
dtNew.Clear(); // 清空数据
for (int i = 0; i < dt.Rows.Count; i++)
{
  if (条件语句)
  {
     dtNew.Rows.Add(dt.Rows[i].ItemArray); // 复制dt表来添加数据行
  }
}
```

克隆表 - 只复制表结构，不包括数据

```csharp
DataTable dtNew = new DataTable();
dtNew = dt.Clone();

// 如果只需要某个表中的某一行
DataTable dtNew = new DataTable();
dtNew = dt.Copy();
dtNew.Rows.Clear(); // 清空表数据
dtNew.ImportRow(dt.Rows[0]); // 加入dt的第一行
```

### 表排序

```csharp
// 创建表
DataTable dt = new DataTable();

// 添加列
dt.Columns.Add("ID", typeof(Int32));
dt.Columns.Add("Name", typeof(String));
dt.Columns.Add("Age", typeof(Int32));

// 添加行
dt.Rows.Add(new object[] { 1, "张三" ,20});
dt.Rows.Add(new object[] { 2, "李四" ,25});
dt.Rows.Add(new object[] { 3, "王五" ,30});

// 获取表视图
DataView dv = dt.DefaultView;
dv.Sort = "ID DESC"; // 按照ID倒序排序
dv.ToTable(); // 转为表
```

# DataSet

```csharp
DataSet ds = new DataSet();
ds.Tables.Add(dt);
ds.Tables.Add(dtSort);
ds.Tables.Add(dtNew2);

foreach (DataTable table in ds.Tables) {
  Console.WriteLine();
    foreach (DataRow rows in table.Rows) { // 遍历每行
      for (int i = 0; i < table.Columns.Count; i++) {
        Console.Write(rows[i] + "\t");
      }
    Console.WriteLine();
  }
}
```



# DataView

# 三者关系

![img](https://daiblog.oss-cn-chengdu.aliyuncs.com/csharp/三者关系.png)

- DataSet：临时数据库
- DataTable：临时数据表

