---
title: 基础语法
date: 2024-09-25 01:42:03
category:
  - [计算机与科学, C#]
tags: C#
cover: https://daiblog.oss-cn-chengdu.aliyuncs.com/cover/2-2.jpg
---

# 本文参考

{% links %}

- site: 月江流语雀笔记
  owner: 月江流
  url: https://www.yuque.com/yuejiangliu/dotnet/timothy-csharp-001
  desc: C# 刘铁猛笔记
  color: "#e9546b"

{% endlinks %}

# 类与名称空间

- 类 `class`：构成程序的主体
- 名称空间 `namespace`：以树型结构组织类（和其他类型）

```csharp
using System; // 引入命名空间

namespace HelloWorld // 命名空间
{
  class Program // 类名与文件名保持一致
  {
    static void Main(string[] args)
    {
      Console.WriteLine("hello!");
    }
  }
}
```

**MSDN 文档（即添加 HelpViewer）**：`开始菜单打开 Visual Studio Installer ➡ 修改 ➡ 单个组件 ➡ 搜索 HelpViewer`

## 类库的引用

使用名称空间的物理基础

不同技术类型的项目会默认引用不同的类库

### DLL 引用（黑盒引用，无源代码）

- `引用 ➡ 右键添加引用 ➡ 浏览 ➡ 手动添加.dll文件`
- `引用 ➡ 右键添加引用 ➡ 程序集 ➡ 搜索添加`

+++success 案例：引用 System.Windows.Forms 来实现窗体

```csharp
using System.Windows.Forms;

namespace HelloWorld
{
  class Program
  {
    static void Main(string[] args)
    {
      Form form = new Form();
      form.ShowDialog();
    }
  }
}
```

+++

#### [NuGet](https://www.nuget.org/) 简介

`引用 ➡ 右键管理 NuGet 程序包 ➡ 浏览下搜索 EntityFramework 安装`

### 项目引用（白盒引用，有源代码）

`引用 ➡ 右键添加引用 ➡ 项目（解决方案右键添加现有项）➡ 选择添加`

一个项目可以应用在多个解决方案上

**自己建类库**：`左上角文件 ➡ 新建 ➡ 项目 ➡ 搜索栏搜类库模板`

## 依赖关系

- 类（或对象）之间的耦合关系

- 优秀的程序追求”高内聚，低耦合“

  教学程序往往会违反这个原则

- UML（通用建模语言）类图

  ![](https://cdn.nlark.com/yuque/0/2018/png/101969/1541852953646-fa634475-2639-44bd-a96e-54b3b1885474.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_474%2Climit_0)

## 排除错误

- 仔细阅读编译器的报错
- MSDN 文档与搜索引擎结合

# 类、对象、类成员

## 定义

类是现实世界事物的模型

类是对现实世界事物进行抽象所得到的结果

- 事物包括”物质”（实体）与“运动”（逻辑）

- 建模是一个去伪存真、由表及里的过程

## 与对象的关系

- 对象也叫实例，是类经过“实例化”后得到的内存中的实体
- 依照类，我们可以创建对象，这就是“实例化”
- 使用 `new` 操作符创建类的实例

- 引用变量与实例的关系

  ```csharp
  (new Form()).Text = "My Form";
  (new Form()).ShowDialog(); // 另一个实例
  
  // 引用变量
  Form myForm = new Form();
  myForm.Text = "My Form";
  myForm.ShowDialog();


## 类的三大成员

- 属性（Property）

  - 存储数据，组合起来表示类或对象当前的状态

- 方法（Method）

  - 由 C 语言中的函数（function）进化而来，表示类或对象“能做什么”

  - 工作中 90% 的时间是与方法打交道，因为它是“真正做事”、“构成逻辑”的成员

- 事件（Event）

  - 类或对象通知其它类或对象的机制，为 C# 所特有（Java 通过其它办法实现这个机制）

- 善用事件机制非常重要（切勿滥用）

😀

某些特殊类或对象在成员方面侧重点不同

- 模型类或对象重在属性，如 Entity Framework

- 工具类或对象重在方法，如 Math，Console

- 通知类或对象重在事件，如各种 Timer

+++success 案例：使用 wpf 实现桌面时钟（侧重事件）

![](https://cdn.nlark.com/yuque/0/2018/png/101969/1541984574217-6966fe44-41ba-4f5b-b970-0b308968daff.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_499%2Climit_0)

```csharp
...
using System.Windows.Threading;

namespace EventSample
{
  public partial class MainWindow : Window
  {
    public MainWindow()
    {
      InitializeComponent();
      DispatcherTimer timer = new DispatcherTimer();
      timer.Interval = TimeSpan.FromSeconds(1);
      timer.Tick += Timer_Tick;
      timer.Start(); // 时钟开始
    }

    private void Timer_Tick(object sender, EventArgs e)
    {
      this.timeTextBox.Text = DateTime.Now.ToString();
    }
  }
}
```

+++

## 静态成员与实例成员

- 静态（Static）成员：类的成员

  物体固有的性质，隶属于某个类

- 实例（非静态）成员：对象的成员

  实例成员是属于对象的，而非类

- 绑定（Binding）指的是编译器如何把一个成员与类或对象关联起来

  不可小觑的 `.` 操作符 —— 成员访问

```csharp
using System.Windows.Forms;

namespace Test
{
  class Program
  {
    static void Main(string[] args)
    {
      Console.WriteLine("静态方法");
      Form form = new Form();
      form.Text = "实例属性";
      form.ShowDialog();
    }
  }
}
```

> 🚩 MSDN 文档中标有 `红色S` 为静态成员

# 基本元素

构成 C# 语言的基本元素

- 关键字（Keyword）

  MSDN 文档位置：`Visual Basic 和 Visual C# ➡ C#参考 ➡ C#关键字`

- 操作符/运算符（Operator）

  MSDN 文档位置：`Visual Basic 和 Visual C# ➡ C#参考 ➡ C#运算符`

- 标识符（Identifier）

- 标点符号

- 文本（字面值）

- 注释与空白

前五种称为标记（token）

## 合法标识符

- 标识符不允许是关键字，如果非要用关键字就在前面加 `@` 符号

- 标识符必需以字符或下划线开头

  字符包括英文字符，也包括汉语、俄语等字符

- 开始字符的后面可以跟字符、数字、下划线

## 命名规范

- 变量名 —— 驼峰命名法 Camel

  首字母小写，后续单词首字母大写

- 方法、类、名称空间 —— 帕斯卡命名法 Pascal

  每个单词的首字母都大写

方法名应该是动词或动词短语

## 字面值

- 整数

  ```csharp
  int x = 10;
  long y = 10L;
  ```

- 实数（小数）

  ```csharp
  float x = 3.0F;
  double y = 4.0;
  ```

- 字符

- 字符串

  ```csharp
  char c = 'a';
  string str = "abc";
  bool a = true;
  ```

- 布尔

- 空 null

## 初识类型、变量、方法

- 初识类型（Type）

  亦称是数据类型（Data Type）

- 变量：存放数据的地方，简称“数据”

  - 变量的声明
  - 变量的使用

- 方法（旧称函数）：处理数据的逻辑，又称“算法”

  - 方法的声明
  - 方法的调用

- 程序 = 数据 + 算法

  有了变量和方法就可以写有意义的程序了

# 类型

Type 又名数据类型（Data Type）

- 小内存容纳大尺寸数据会丢失精度、发生错误
- 大内存容纳小尺寸数据会导致浪费
- 编程语言的数据类型与数据的数据类型不完全相同

强类型语言与弱类型语言

- 强类型：编写程序时，程序中的数据受到数据类型的约束

- 弱类型：数据受类型约束不严格，或基本不受约束（如 JavaScript 动态类型）

- C# 从 4.0 开始引入了 Dynamic，让它可以利用动态语言的一些特性，但 C# 依然是强类型编程语言

  ```csharp
  namespace DynamicSample
  {
    class Program
    {
      static void Main(string[] args)
     {
        dynamic myVar = 100;
        Console.WriteLine(myVar);
        myVar = "Mr.Okay!";
        Console.WriteLine(myVar);
      }
    }
  }
  ```

## 作用

- 存储此类型变量所需的内存空间大小
- 此类型的值可表示的最大、最小值范围
- 此类型所包含的成员（如方法、属性、事件等）
- 此类型由何基类派生而来
- 程序运行的时候，此类型的变量被分配在内存的什么位置
  - Stack 简介
  - Stack overflow
  - Heap 简介
  - 使用 Performance Monitor 查看进程的堆内存使用量
  - 关于内存泄漏
- 此类型所允许的操作（运算）

对一个程序来说，静态指编辑期、编译期；动态指运行期
静态时装在硬盘里，动态时装在内存里

## 反射

```csharp
static void Main(string[] args)
{
    Type myType = typeof(Form);
    Console.WriteLine(myType.BaseType.FullName + Environment.NewLine + myType.FullName);
    var pInfos = myType.GetProperties();
    foreach (var p in pInfos)
    {
        Console.WriteLine(p.Name);
    }
    var mInfos = myType.GetMethods();
    foreach (var m in mInfos)
    {
        Console.WriteLine(m.Name);
    }
}
```



## 五大数据类型

- 类（Classes）：如 Windows、Forms、Console、String
- 结构体（Structures）：如 Int32、Int64、Single、Double
- 枚举（Enumerations）：如 HorizontalAlignment、Visibility
- 接口（Interfaces）
- 委托（Delegates）

# 方法

# 操作符

# 表达式

# 语句

# 字段

# 属性

# 索引器

# 常量

# 参数

# 委托

# 数据类型

- 值类型：简单类型（如 int、float、bool 和 char）、枚举类型、结构类型、Nullable 值类型
- 引用类型：类类型、接口类型、数组类型、委托类型

![数据类型](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fefbc908dfcb4436bcda4911220528f4~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

| 描述                  | 类型                                                         |
| --------------------- | ------------------------------------------------------------ |
| Unicode 字符（16 位） | char                                                         |
| 布尔值                | bool                                                         |
| 有符号整数            | sbyte（8 位）< short（16 位）< int（32 位）< long（64 位）   |
| 正整数                | byte（8 位）< ushort（16 位）< uint（32 位）< ulong（64 位） |
| 浮点数                | float（32 位）< double（64 位）                              |
| 时间                  | DateTime                                                     |

可空类型：声明时加个 `?`，才可赋值为 null

## 值类型

| 类型    | 描述                                        | 范围                                                    | 默认值 |
| ------- | ------------------------------------------- | ------------------------------------------------------- | ------ |
| bool    | 布尔值                                      | True 或 False                                           | False  |
| byte    | 8 位无符号整数                              | 0 到 255                                                | 0      |
| char    | 16 位 Unicode 字符                          | U +0000 到 U +ffff                                      | '\0'   |
| decimal | 128 位精确的十进制值，具有 28~29 个有效位数 | (-7.9 x 1028 到 7.9 x 1028) / 100 到 28                 | 0.0M   |
| double  | 64 位双精度浮点型                           | (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308                   | 0.0D   |
| float   | 32 位单精度浮点型                           | -3.4 x 1038 到 + 3.4 x 1038                             | 0.0F   |
| int     | 32 位有符号整数类型                         | -2,147,483,648 到 2,147,483,647                         | 0      |
| long    | 64 位有符号整数类型                         | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 | 0L     |
| sbyte   | 8 位有符号整数类型                          | -128 到 127                                             | 0      |
| short   | 16 位有符号整数类型                         | -32,768 到 32,767                                       | 0      |
| uint    | 32 位无符号整数类型                         | 0 到 4,294,967,295                                      | 0      |
| ulong   | 64 位无符号整数类型                         | 0 到 18,446,744,073,709,551,615                         | 0      |
| ushort  | 16 位无符号整数类型                         | 0 到 65,535                                             | 0      |

使用 `sizeof()` 获取类型或变量的大小

## 引用类型

### 对象类型 Object

```csharp
Object obj;
obj = 100; // 装箱
```

### 动态类型 Dynamic

可以存储任何类型的值在动态数据类型变量中

```csharp
dynamic d = 20;
```

### 字符串类型 String

字符串（String）类型是 System.String 类的别名

通过两种形式进行分配：`引号 和 @引号`

```csharp
String str = "zhudaidai";

// @（称作"逐字字符串"）将转义字符（\）当作普通字符对待，若要显示"，则要打多个"
string str = @"C:\Windows"""; // 输出 C:\Windows"
等同于
string str = "C:\\Windows"; // 输出 C:\Windows

// @内可以任意换行：换行符及缩进空格都计算在字符串长度之内
string str = @"<script type=""text/javascript"">
  <!--
  -->
</script>";
```

## 指针类型

# 运算符

## 算术运算符

假设 `A=10 B=20`

| 运算符 | 描述                             | 实例              |
| :----- | :------------------------------- | :---------------- |
| +      | 把两个操作数相加                 | A + B 将得到 30   |
| -      | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10  |
| \*     | 把两个操作数相乘                 | A \* B 将得到 200 |
| /      | 分子除以分母                     | B / A 将得到 2    |
| %      | 取模运算符，整除后的余数         | B % A 将得到 0    |
| ++     | 自增运算符，整数值增加 1         | A++ 将得到 11     |
| --     | 自减运算符，整数值减少 1         | A-- 将得到 9      |

## 关系运算符

假设 `A=10 B=20`

| 运算符 | 描述                                                         | 实例            |
| :----- | :----------------------------------------------------------- | :-------------- |
| ==     | 检查两个操作数的值是否相等，如果相等则条件为真               | (A == B) 不为真 |
| !=     | 检查两个操作数的值是否相等，如果不相等则条件为真             | (A != B) 为真   |
| >      | 检查左操作数的值是否大于右操作数的值，如果是则条件为真       | (A > B) 不为真  |
| <      | 检查左操作数的值是否小于右操作数的值，如果是则条件为真       | (A < B) 为真    |
| >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真 | (A >= B) 不为真 |
| <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真 | (A <= B) 为真   |

## 逻辑运算符

假设 `A=true B=false`

| 运算符 | 描述                                                                         | 实例            |
| :----- | :--------------------------------------------------------------------------- | :-------------- |
| &&     | 逻辑与运算符。如果两个操作数都非零，则条件为真                               | (A && B) 为假   |
| \|\|   | 逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真                     | (A \|\| B) 为真 |
| !      | 逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假 |                 |

## 合并运算符

合并运算符 `??`：如果第一个操作数的值为 null，则运算符返回第二个操作数的值，否则返回第一个操作数的值

```csharp
int? num1 = null;
int num2 = num1 ?? 123;

// 可以理解为三元运算符的简化形式
int num2 = (num1 == null) ? 123 : num1;
```

## 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p   | q   | p & q | p \| q | p ^ q |
| :-- | :-- | :---- | :----- | :---- |
| 0   | 0   | 0     | 0      | 0     |
| 0   | 1   | 0     | 1      | 1     |
| 1   | 1   | 1     | 1      | 0     |
| 1   | 0   | 0     | 1      | 1     |

假设 `A=60 B=13`

| 运算符 | 描述                                                                                   | 实例                                                           |
| :----- | :------------------------------------------------------------------------------------- | :------------------------------------------------------------- |
| &      | 如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中                          | (A & B) 将得到 12，即为 0000 1100                              |
| \|     | 如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中                               | (A \| B) 将得到 61，即为 0011 1101                             |
| ^      | 如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中 | (A ^ B) 将得到 49，即为 0011 0001                              |
| ~      | 按位取反运算符是一元运算符，具有"翻转"位效果，即 0 变成 1，1 变成 0，包括符号位        | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式 |
| <<     | 二进制左移运算符。左操作数的值向左移动右操作数指定的位数                               | A << 2 将得到 240，即为 1111 0000                              |
| >>     | 二进制右移运算符。左操作数的值向右移动右操作数指定的位数                               | A >> 2 将得到 15，即为 0000 1111                               |

+++success 案例

```csharp
int a = 60; // 60 = 0011 1100
int b = 13; // 13 = 0000 1101
int c = 0;

c = a & b; // 12 = 0000 1100
Console.WriteLine("Line 1 - c 的值是 {0}", c);

c = a | b; // 61 = 0011 1101
Console.WriteLine("Line 2 - c 的值是 {0}", c);

c = a ^ b; // 49 = 0011 0001
Console.WriteLine("Line 3 - c 的值是 {0}", c);

c = ~a; // -61 = 1100 0011
Console.WriteLine("Line 4 - c 的值是 {0}", c);

c = a << 2; // 240 = 1111 0000
Console.WriteLine("Line 5 - c 的值是 {0}", c);

c = a >> 2; // 15 = 0000 1111
Console.WriteLine("Line 6 - c 的值是 {0}", c);
Console.ReadLine();
```

+++

## 赋值运算符

| 运算符 | 描述                                                             | 实例                            |
| :----- | :--------------------------------------------------------------- | :------------------------------ |
| =      | 简单的赋值运算符，把右边操作数的值赋给左边操作数                 | C = A + B 将把 A + B 的值赋给 C |
| +=     | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A         |
| -=     | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A         |
| \*=    | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C _= A 相当于 C = C_ A          |
| /=     | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A         |
| %=     | 求模且赋值运算符，求两个操作数的模赋值给左边操作数               | C %= A 相当于 C = C % A         |
| <<=    | 左移且赋值运算符                                                 | C <<= 2 等同于 C = C << 2       |
| >>=    | 右移且赋值运算符                                                 | C >>= 2 等同于 C = C >> 2       |
| &=     | 按位与且赋值运算符                                               | C &= 2 等同于 C = C & 2         |
| ^=     | 按位异或且赋值运算符                                             | C ^= 2 等同于 C = C ^ 2         |
| \|=    | 按位或且赋值运算符                                               | C \|= 2 等同于 C = C \| 2       |

## 其他运算符

| 运算符   | 描述                                 | 实例                                                                              |
| :------- | :----------------------------------- | :-------------------------------------------------------------------------------- |
| sizeof() | 返回数据类型的大小                   | sizeof(int)，将返回 4                                                             |
| typeof() | 返回 class 的类型                    | typeof(StreamReader);                                                             |
| &        | 返回变量的地址                       | &a; 将得到变量的实际地址。                                                        |
| \*       | 变量的指针                           | \*a; 将指向一个变量。                                                             |
| ? :      | 条件表达式                           | 如果条件为真 ? 则为 X : 否则为 Y                                                  |
| is       | 判断对象是否为某一类型               | If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。                           |
| as       | 强制转换，即使转换失败也不会抛出异常 | Object obj = new StringReader("Hello"); <br>StringReader r = obj as StringReader; |

+++success 案例

```csharp
Console.WriteLine("int 的大小是 {0}", sizeof(int)); // int的大小是4
Console.WriteLine("short 的大小是 {0}", sizeof(short)); // short的大小是2

Type type = typeof(string);
Console.WriteLine(type.FullName); // System.String
Console.ReadKey();
```

+++

## 运算符优先级

| 类别       | 运算符                              | 结合性   |
| :--------- | :---------------------------------- | :------- |
| 后缀       | () [] -> . ++ - -                   | 从左到右 |
| 一元       | + - ! ~ ++ - - (type)\* & sizeof    | 从右到左 |
| 乘除       | \* / %                              | 从左到右 |
| 加减       | + -                                 | 从左到右 |
| 移位       | << >>                               | 从左到右 |
| 关系       | < <= > >=                           | 从左到右 |
| 相等       | == !=                               | 从左到右 |
| 位与 AND   | &                                   | 从左到右 |
| 位异或 XOR | ^                                   | 从左到右 |
| 位或 OR    | \|                                  | 从左到右 |
| 逻辑与 AND | &&                                  | 从左到右 |
| 逻辑或 OR  | \|\|                                | 从左到右 |
| 条件       | ?:                                  | 从右到左 |
| 赋值       | = += -= \*= /= %= >>= <<= &= ^= \|= | 从右到左 |
| 逗号       | ,                                   | 从左到右 |

# 条件/分支

## if

```csharp
if (条件)
{
  ...
}
else if ()
{
  ...
}
else
{
  ...
}
```

## switch

```csharp
switch (变量)
{
  case 条件1:
    ...
    break;
  case 条件2:
    ...
    break;
  default:
    ...
    break;
}
```

## 三元运算符

```csharp
Exp1 ? Exp2 : Exp3;
```

# 循环

| 循环类型         | 描述                                                               | 使用场景       |
| :--------------- | ------------------------------------------------------------------ | :------------- |
| while 循环       | 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件 | 确定循环条件   |
| for/foreach 循环 | 多次执行一个语句序列，简化管理循环变量的代码                       | 确定次数       |
| do...while 循环  | 除了它是在循环主体结尾测试条件外，其他与 while 语句类似            | 至少被执行一次 |
| 嵌套循环         | 可以在 while、for 或 do..while 循环内使用一个或多个循环            |                |

```csharp
int i = 0;
while(i < 10)
{
  Console.WriteLine(i);
  i++;
}


int i = 0;
do
{
  Console.WriteLine(i);
  i++;
} while (i < 10);


for (int i = 0; i < 10; i++)
{
  Console.WriteLine(i);
}

int i = 0;
for ( ; i < 10; )
{
  Console.WriteLine(i);
  i++;
}
for( ; ; ) // 死循环
```

## 循环控制语句

| 控制语句      | 描述                       |
| ------------- | -------------------------- |
| break 语句    | 结束整个循环               |
| continue 语句 | 中止当前循环，继续下次循环 |

# 方法（函数）

```csharp
<Access Specifier> <Return Type> <Method Name>(Parameter List)
{
  Method Body
}

➡ Access Specifier：访问修饰符
➡ Return type：返回类型，一个方法可以返回一个值
➡ Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。
➡ Parameter list：参数列表
➡ Method body：方法主体
```

+++success 举例

```csharp
// 普通方法
public void sayHi() {
  Console.WriteLine("hi");
}

// 带参数的方法
public void sayHi(string name) {
  Console.WriteLine("hi,{0}", name);
}

// 带参数的返回值的方法
public int add(int a, int b) {
  int sum = a + b;
  return sum;
}
```

+++
