---
title: 委托
date: 2024-11-07 16:37:53
category:
  - [计算机与科学, C#]
tags: C#
cover: https://daiblog.oss-cn-chengdu.aliyuncs.com/cover/2-5.jpg
---

# 定义

- **委托（delegate）是函数指针的“升级版”**
  - 示例：C/C++ 中的函数指针
- **一切皆地址**
  - 变量（数据）是以某个地址为起点的一段内存中所存储的值
  - 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令
- **直接调用与间接调用**
  - 直接调用：通过函数名来调用函数    ，CPU 通过函数名直接获得函数所在地址并开始执行 -> 返回
  - 间接调用：通过函数指针来调用函数，CPU 通过读取函数指针存储的值获得函数所在地址并开始执行 -> 返回
- **Java 中没有与委托相对应的功能实体**
- **委托的简单使用**
  - Action 委托
  - Func 委托

## C 语言函数指针

+++info 声明函数指针与函数

```c
#include <stdio.h>

int(*Calc)(int a, int b);

int Add(int a, int b)
{
    int result = a + b;
    return result;
}
int Sub(int a, int b)
{
    int result = a - b;
    return result;
}
```

+++

+++primary 使用函数指针

```c
int main()
{
    int x = 100;
    int y = 200;
    int z = 0;
    
    Calc funcPoint1 = &Add;
    Calc funcPoint2 = &Sub;
    
    z = funcPoint1(x, y);
    printf("%d+%d=%d\n", x, y, z);
    
    z = funcPoint2(x, y);
    printf("%d+%d=%d\n", x, y, z);
    
    system("pause");
    return 0;
}
```

+++

## Java

Java 语言由 C++ 发展而来，为了提高应用安全性，Java 语言禁止程序员直接访问内存地址

即 Java 语言把 C++ 中所有与指针相关的内容都舍弃掉了

## 委托实例 Action 与 Func

Action 和 Func 是 C# 内置的委托实例，它们都有很多重载以方便使用

+++success 示例

```csharp
class Program
{
    static void Main(string[] args)
    {
        var calculator = new Calculator();
        // Action 用于无形参无返回值的方法
        Action action = new Action(calculator.Report);
        calculator.Report();
        action.Invoke();
        // 模仿函数指针的简略写法
        action();

        Func<int, int, int> func1 = new Func<int, int, int>(calculator.Add);
        Func<int, int, int> func2 = new Func<int, int, int>(calculator.Sub);

        int x = 100;
        int y = 200;
        int z = 0;

        z = func1.Invoke(x, y);
        Console.WriteLine(z);
        z = func2.Invoke(x, y);
        Console.WriteLine(z);

        // Func 也有简略写法
        z = func1(x, y);
        Console.WriteLine(z);
        z = func2(x, y);
        Console.WriteLine(z);
    }
}
class Calculator
{
    public void Report()
    {
        Console.WriteLine("I have 3 methods.");
    }

    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Sub(int a, int b)
    {
        return a - b;
    }
}
```

+++

# 声明



# 一般使用

## 模板方法

利用模板方法，提高代码复用性

## 回调方法

通过委托类型参数传入主调方法的被调用方法，主调方法根据自己的逻辑决定是否调用这个方法

## 注意委托滥用

# 高级使用

## 多播（multicast）委托



## 隐式异步调用

### 三种同步调用



### 使用委托进行隐式异步调用 BeginInvoke



### 使用 Thread 与 Task 进行异步调用



## 适时地使用接口（interface）取代委托
