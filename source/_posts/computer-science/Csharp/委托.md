---
title: 委托
date: 2024-11-07 16:37:53
category:
  - [计算机与科学, C#]
tags: C#
cover: https://daiblog.oss-cn-chengdu.aliyuncs.com/cover/2-5.jpg
---

# 定义

- **委托（delegate）是函数指针的“升级版”**
  - 示例：C/C++ 中的函数指针
- **一切皆地址**
  - 变量（数据）是以某个地址为起点的一段内存中所存储的值
  - 函数（算法）是以某个地址为起点的一段内存中所存储的一组机器语言指令
- **直接调用与间接调用**
  - 直接调用：通过函数名来调用函数，CPU 通过函数名直接获得函数所在地址并开始执行 ➡ 返回
  - 间接调用：通过函数指针来调用函数，CPU 通过读取函数指针存储的值获得函数所在地址并开始执行 ➡ 返回
- **Java 中没有与委托相对应的功能实体**
- **委托的简单使用**
  - Action 委托
  - Func 委托

## C 语言函数指针

+++info 直接调用

```c
#include <stdio.h>

int Add(int a, int b)
{
    int result = a + b;
    return result;
}
int Sub(int a, int b)
{
    int result = a - b;
    return result;
}

int main()
{
    int x = 100;
    int y = 200;
    int z = 0;
    
    z = Add(x, y);
    printf("%d+%d=%d\n", x, y, z); 
    z = Sub(x, y);
    printf("%d+%d=%d\n", x, y, z);
    
    system("pause");
    return 0;
}
```

+++

+++primary 间接调用：函数指针

```c
#include <stdio.h>

typedef int(* Calc)(int a, int b); // 声明函数指针类型

int Add(int a, int b)
{
    int result = a + b;
    return result;
}
int Sub(int a, int b)
{
    int result = a - b;
    return result;
}

int main()
{
    int x = 100;
    int y = 200;
    int z = 0;
    
    Calc funcPoint1 = &Add; // 声明函数指针类型的变量
    Calc funcPoint2 = &Sub;
    
    z = funcPoint1(x, y);
    printf("%d+%d=%d\n", x, y, z);
    
    z = funcPoint2(x, y);
    printf("%d+%d=%d\n", x, y, z);
    
    system("pause");
    return 0;
}
```

+++

## Java

Java 语言由 C++ 发展而来，为了提高应用安全性，Java 语言禁止程序员直接访问内存地址

即 Java 语言把 C++ 中所有与指针相关的内容都舍弃掉了

## 委托实例 Action 与 Func

Action 和 Func 是 C# 内置的委托实例，它们都有很多重载以方便使用

+++success 示例：Action 

```csharp
class Program
{
    static void Main(string[] args)
    {
        Calculator calculator = new Calculator();
        calculator.Report(); // 直接调用
        
        Action action = new Action(calculator.Report); // Action 用于无形参无返回值的方法
        action.Invoke(); // 间接调用
        action(); // 模仿函数指针的简略写法
    }
}
class Calculator
{
    public void Report()
    {
        Console.WriteLine("I have 3 methods.");
    }

    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Sub(int a, int b)
    {
        return a - b;
    }
}
```

+++

+++success 示例：Func

```csharp
class Program
{
    static void Main(string[] args)
    {
        Calculator calculator = new Calculator();

        Func<int, int, int> func1 = new Func<int, int, int>(calculator.Add);
        Func<int, int, int> func2 = new Func<int, int, int>(calculator.Sub);

        int x = 100;
        int y = 200;
        int z = 0;

        z = func1.Invoke(x, y);
        Console.WriteLine(z);
        z = func2.Invoke(x, y);
        Console.WriteLine(z);

        // Func 也有简略写法
        z = func1(x, y);
        z = func2(x, y);
    }
}
class Calculator
{
    public void Report()
    {
        Console.WriteLine("I have 3 methods.");
    }

    public int Add(int a, int b)
    {
        return a + b;
    }

    public int Sub(int a, int b)
    {
        return a - b;
    }
}
```

+++

# 声明（自定义委托）

- 委托是一种类（class），类是数据类型，所以委托也是一种数据类型
- 声明方式与一般的类不同，主要是为了照顾可读性和 C/C++ 传统
- 注意声明委托的位置
  - 避免写错地方结果声明成嵌套类型
- 委托与所封装的方法必须“类型兼容”
  - 返回值的数据类型一致
  - 参数列表在个数和数据类型上一致（参数名不需要一样）

委托是类，所以声明位置是和 class 处于同一个级别。但 C# 允许嵌套声明类（一个类里面可以声明另一个类），所以有时也会有 delegate 在 class 内部声明的情况

```csharp
static void Main(string[] args)
{
    Type t = typeof(Action);
    Console.WriteLine(t.IsClass); // True
}
```

+++ 示例

```csharp
public delegate double Calc(double x, double y);

class Program
{
    static void Main(string[] args)
    {
        Calculator calculator = new Calculator();
        Calc calc1 = new Calc(calculator.Mul);

        Console.WriteLine(calc1(5, 6));
    }
}

class Calculator
{
    public double Mul(double x, double y)
    {
        return x * y;
    }

    public double Div(double x, double y)
    {
        return x / y;
    }
}
```

+++

# 一般使用

把方法当作参数传给另一个方法

- 模版方法，“借用”指定的外部方法来产生结果
  - 相当于“填空题”
  - 常位于代码中部
  - 委托有返回值
- 回调（callback）方法，调用指定的外部方法
  - 相当于“流水线”
  - 常位于代码尾部
  - 委托无返回值

> :warning: 注意：难精通 + 易使用 + 功能强大东西，一旦被滥用则后果非常严重
>
> 缺点：
>
> - 这是一种方法级别的紧耦合，现实工作中要慎之又慎
> - 使可读性下降、debug 的难度增加
> - 把委托回调、异步调用和多线程纠缠在一起，会让代码变得难以阅读和维护
> - 委托使用不当有可能造成内存泄漏和程序性能下降

## 模板方法

利用模板方法，提高代码复用性

## 回调方法

通过委托类型参数传入主调方法的被调用方法，主调方法根据自己的逻辑决定是否调用这个方法

## 注意委托滥用

# 高级使用

![img](https://cdn.nlark.com/yuque/0/2018/png/101969/1538890098631-b057cc4b-861f-4c63-b3a5-154359f10756.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_827%2Climit_0)

## 多播（multicast）委托



## 隐式异步调用

### 三种同步调用



### 使用委托进行隐式异步调用 BeginInvoke



### 使用 Thread 与 Task 进行异步调用



## 适时地使用接口（interface）取代委托
