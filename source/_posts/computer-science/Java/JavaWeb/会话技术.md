---
title: 会话技术
date: 2025-08-06 16:14:02
category:
  - [计算机与科学, Java, JavaWeb]
tags: JavaWeb
cover: https://daiblog.oss-cn-chengdu.aliyuncs.com/cover/6-11.jpg
---

# 概述

## 会话

用户打开浏览器，访问 web 服务器的资源，会话建立，直到有一方断开连接，会话结束

在一次会话中可以包含<font color=red>多次</font>请求和响应

> - 从浏览器发出请求到服务端响应数据给前端之后，一次会话（在浏览器和服务器之间）就被建立了
> - 会话被建立后，如果浏览器或服务端都没有被关闭，则会话就会持续建立着
> - 浏览器和服务器就可以继续使用该会话进行请求发送和响应，上述的整个过程称为**会话**

![image-20250806163642441](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250806163642441.png)

上图中，每个浏览器都会与服务端建立了一个会话，总共是 3 个会话

## 会话跟踪

一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<font color=red>共享数据</font>

> - 服务器会收到多个请求，这多个请求可能来自多个浏览器，如上图中的 6 个请求来自 3 个浏览器
> - 服务器需要用来识别请求是否来自同一个浏览器
> - 服务器用来识别浏览器的过程，这个过程就是**会话跟踪**
> - 服务器识别浏览器后就可以在同一个会话中多次请求之间来共享数据

思考：为什么现在浏览器和服务器不支持数据共享？

- 浏览器和服务器之间使用的是 HTTP 请求来进行数据传输
- HTTP 协议是**无状态**的，每次浏览器向服务器请求时，服务器都会将该请求视为**新的**请求
- HTTP 协议设计成无状态的目的是让每次请求之间相互独立，互不影响
- 请求与请求之间独立后，就无法实现多次请求之间的数据共享

**实现方式**：

- 客户端会话跟踪技术：Cookie
- 服务端会话跟踪技术：Session

# Cookie

客户端会话技术，将数据保存到客户端，以后每次请求都携带 Cookie 数据进行访问

## 基本使用

**工作流程**：

![image-20250806164903929](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250806164903929.png)

> - 服务端提供了两个 Servlet，分别是 ServletA 和 ServletB
> - 浏览器发送 HTTP 请求 1 给服务端，服务端 ServletA 接收请求并进行业务处理
> - 服务端 ServletA 在处理的过程中可以创建一个 Cookie 对象并将 `name=zs` 的数据存入 Cookie
> - 服务端 ServletA 在响应数据的时候，会把 Cookie 对象响应给浏览器
> - 浏览器接收到响应数据，会把 Cookie 对象中的数据存储在浏览器内存中，此时浏览器和服务端就**建立了一次会话**
> - **在同一次会话**中浏览器再次发送 HTTP 请求 2 给服务端 ServletB，浏览器会携带 Cookie 对象中的所有数据
> - ServletB 接收到请求和数据后，就可以获取到存储在 Cookie 对象中的数据，这样同一个会话中的多次请求之间就实现了数据共享

### 发送 Cookie

```java
// 1、创建Cookie对象，设置数据
Cookie cookie = new Cookie("key", "value");
// 2、发送Cookie到客户端：使用response对象
response.addCookie(cookie);
```

浏览器查看 Cookie 的值

![image-20250811115401854](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250811115401854.png)

### 获取 Cookie

```java
// 1、获取客户端携带的所有Cookie，使用request对象
Cookie[] cookies = request.getCookies();

// 2、遍历数组，获取每一个Cookie对象：for

// 3、使用Cookie对象方法获取数据
cookie.getName();
cookie.getValue();
```

## 原理分析

Cookie 的实现是基于 HTTP 协议的

- 响应头：set-cookie
- 请求头：cookie

![image-20250811134009443](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250811134009443.png)

> - 当 Tomcat 发现后端要返回的是一个 Cookie 对象之后，Tomcat 就会在响应头中添加一行数据 `Set-Cookie:username=zs`
>
>   ![image-20250811134459726](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250811134459726.png)
>
> - 浏览器获取到响应结果后，从响应头中就可以获取到 `Set-Cookie` 对应值 `username=zs`，并将数据存储在浏览器的内存中
>
> - 浏览器再次发送请求给 BServlet 的时候，浏览器会自动在请求头中添加 `Cookie: username=zs` 发送给服务端 BServlet
>
>   ![image-20250811134516075](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250811134516075.png)

## 使用细节

### Cookie 存活时间

默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则 Cookie 被销毁

```java
// 设置Cookie存活时间
setMaxAge(int seconds)

* 正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除
* 负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁
* 零：删除对应Cookie
```

### Cookie 存储中文

Cookie 不能直接存储中文

如需要存储，则需要进行转码：URL 编码

## 代码示例

发送 Cookie

```java
@WebServlet("/aServlet")
public class AServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 发送Cookie
        String value = "张三";
        // 对中文进行URL编码
        value = URLEncoder.encode(value, "UTF-8");
        // 1、创建Cookie对象
        Cookie cookie = new Cookie("username", value);
        // 设置存活时间
        cookie.setMaxAge(60 * 60 * 24 * 7);
        // 2、发送Cookie
        resp.addCookie(cookie);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
```

获取 Cookie

```java
@WebServlet("/bServlet")
public class BServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取Cookie
        // 1、获取Cookie数组
        Cookie[] cookies = req.getCookies();
        // 2、遍历数组
        for (Cookie cookie : cookies) {
            // 3、获取数据
            String name = cookie.getName();
            if ("username".equals(name)) {
                String value = cookie.getValue();
                // URL解码
                value = URLDecoder.decode(value, "UTF-8");
                System.out.println(name + ":" + value);
                break;
            }
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
```

# Session

服务端会话跟踪技术：将数据保存到服务端

JavaEE 提供 HttpSession 接口，来实现一次会话的多次请求间数据共享功能

- 存储在客户端的数据容易被窃取和截获，存在很多不安全的因素
- 存储在服务端的数据相比于客户端来说就更安全

## 基本使用

**工作流程**：

![image-20250811141153129](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250811141153129.png)

> - 在服务端的 AServlet 获取一个 Session 对象，把数据存入其中
> - 在服务端的 BServlet 获取到相同的 Session 对象，从中取出数据
> - 就可以实现一次会话中多次请求之间的数据共享了

```java
// 1、获取Session对象，使用的是request对象
HttpSession session = request.getSession();

//2、Session对象功能
// 存储数据到session域中
void setAttribute(String name, Object o)

// 根据key，获取值
Object getAttribute(String name)

// 根据key，删除该键值对
void removeAttribute(String name)
```

## 原理分析

Session 是基于 Cookie 实现的

Session 要想实现一次会话多次请求之间的数据共享，就必须要保证多次请求获取 Session 的对象是同一个

![image-20250812093047522](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250812093047522.png)

> Session 是如何保证在一次会话中获取的 Session 对象是同一个呢？
>
> - Tomcat 服务器发现业务处理中使用了 Session 对象，就会把 Session 的唯一标识 `id:10` 当做一个 cookie，添加 `Set-Cookie:JESSIONID=10` 到响应头中，并响应给浏览器
>
>   ![image-20250812093513426](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250812093513426.png)
>
> - 浏览器接收到响应结果后，会把响应头中的 coookie 数据存储到浏览器的内存中
>
> - 浏览器在同一会话中访问 demo2 的时候，会把 cookie 中的数据按照 `cookie: JESSIONID=10` 的格式添加到请求头中并发送给服务器 Tomcat
>
>   ![image-20250812093550511](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250812093550511.png)
>
> - demo2 获取到请求后，从请求头中就读取 cookie 中的 JSESSIONID 值为 10，然后就会到服务器内存中寻找 `id:10` 的 Session 对象，如果找到了，就直接返回该对象，如果没有则新创建一个 Session 对象
>
> - 关闭打开浏览器后，因为浏览器的 cookie 已被销毁，所以就没有 JESSIONID 的数据，服务端获取到的 Session 就是一个全新的 Session 对象

## 使用细节

### Session 钝化与活化

- 钝化：在服务器正常关闭后，Tomcat 会自动将 Session 数据写入硬盘的文件中

  - 钝化的数据路径为：`项目目录\target\tomcat\work\Tomcat\localhost\项目名称\SESSIONS.ser`

    ![image-20250812093923076](https://daiblog.oss-cn-chengdu.aliyuncs.com/img/image-20250812093923076.png)

- 活化：再次启动服务器后，从文件中加载数据到 Session 中

  - 数据加载到 Session 中后，`SESSIONS.ser` 文件会被删除掉

### Session 销毁

方式一：默认情况下，无操作，30 分钟自动销毁

在项目的 `src/main/webapp/WEB-INF/web.xml` 中配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <session-config>
        <session-timeout>100</session-timeout>
    </session-config>
</web-app>
```

默认值是在 Tomcat 的 web.xml 配置文件中写死的

```xml
<session-config>
    <session-timeout>30</session-timeout>
</session-config>
```

方式二：调用 Session 对象的 `invalidate()` 方法

```java
session.invalidate();
```

## 代码示例

存储到 Session

```java
@WebServlet("/demo1")
public class SessionDemo1 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 存储到Session
        // 1、获取Session对象
        HttpSession session = req.getSession();
        // 2、存储数据
        session.setAttribute("username", "zs");
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
```

获取数据

```java
@WebServlet("/demo2")
public class SessionDemo2 extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 获取数据
        // 1、获取Session对象
        HttpSession session = req.getSession();
        // 销毁
        session.invalidate();
        // 2、获取数据
        Object username = session.getAttribute("username");
        System.out.println(username);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        this.doGet(req, resp);
    }
}
```

# 区别

Cookie 和 Session 都是来完成一次会话内多次请求间<font color=red>数据共享</font>的

- 存储位置：Cookie 是将数据存储在客户端，Session 将数据存储在服务端
- 安全性：Cookie 不安全，Session 安全
- 数据大小：Cookie 最大 3KB，Session 无大小限制
- 存储时间：Cookie 可以通过 `setMaxAge()` 长期存储，Session 默认 30 分钟
- 服务器性能：Cookie 不占服务器资源，Session 占用服务器资源

**应用场景**：

- Cookie 是用来保证用户在未登录情况下的身份识别
- Session 是用来保存用户登录后的数据
